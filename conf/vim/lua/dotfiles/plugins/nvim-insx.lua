return {
	-- "hrsh7th/nvim-insx", -- Autopairs
	-- event = "InsertEnter",
	-- init = function()
	-- 	-- Lexima Settings:
	-- 	vim.g.lexima_map_escape = ""
	-- 	vim.g.lexima_enable_space_rules = 0
	-- 	vim.g.lexima_enable_endwise_rules = 1
	-- 	vim.g.lexima_disable_closetag = 0
	-- 	vim.g.lexima_no_default_rules = 0
	-- end,
	-- config = function()
	-- 	local function get(key, default)
	-- 		return vim.g[key] or default
	-- 	end
	-- 	vim.g.lexima_no_default_rules = get("lexima_no_default_rules", 0)
	-- 	vim.g.lexima_no_map_to_escape = get("lexima_no_map_to_escape", 0)
	-- 	vim.g.lexima_enable_basic_rules = get("lexima_enable_basic_rules", 1)
	-- 	vim.g.lexima_enable_newline_rules = get("lexima_enable_newline_rules", 1)
	-- 	vim.g.lexima_enable_space_rules = get("lexima_enable_space_rules", 1)
	-- 	vim.g.lexima_enable_endwise_rules = get("lexima_enable_endwise_rules", 1)
	-- 	vim.g.lexima_accept_pum_with_enter = get("lexima_accept_pum_with_enter", vim.fn.has("nvim"))
	-- 	vim.g.lexima_ctrlh_as_backspace = get("lexima_ctrlh_as_backspace", 0)
	-- 	vim.g.lexima_disable_on_nofile = get("lexima_disable_on_nofile", 0)
	-- 	vim.g.lexima_disable_abbrev_trigger = get("lexima_disable_abbrev_trigger", 0)
	--
	-- 	local insx = require("insx")
	--
	-- 	local function add_rule(rule)
	-- 		insx.add(rule.char, require("insx.recipe.lexima")(rule))
	-- 	end
	--
	-- 	local function make_endwise_rule(at, ed, ft, syn)
	-- 		add_rule({
	-- 			char = "<CR>",
	-- 			input = "<CR>",
	-- 			input_after = "<CR>" .. ed,
	-- 			at = at,
	-- 			except = [[\C\v^(\s*)\S.*\%#\n%(%(\s*|\1\s.+)\n)*\1]] .. ed,
	-- 			filetype = ft,
	-- 			syntax = syn,
	-- 		})
	-- 	end
	--
	-- 	-- Rule Making Functions:
	-- 	local function make_markdown_bi_rule(char, escape)
	-- 		local esc_char = escape and [[\]] .. char or char
	-- 		add_rule({
	-- 			char = char,
	-- 			input_after = char,
	-- 			filetype = { "text", "markdown" },
	-- 			except = esc_char .. esc_char .. [[.*\%#]] .. esc_char .. esc_char,
	-- 		}) -- Create italic pair
	-- 		add_rule({
	-- 			char = "<Space>",
	-- 			delete = 1,
	-- 			filetype = { "text", "markdown" },
	-- 			except = "^" .. esc_char .. [[\%#]] .. esc_char,
	-- 		}) -- Handle bulleted item
	-- 		add_rule({
	-- 			char = char,
	-- 			at = [[\%#]] .. esc_char,
	-- 			leave = char,
	-- 			filetype = { "text", "markdown" },
	-- 			except = esc_char .. [[\{1\}\%#]],
	-- 		}) -- Leave italic pair
	-- 		add_rule({
	-- 			char = char,
	-- 			at = esc_char .. esc_char .. [[.*\%#]] .. esc_char .. esc_char,
	-- 			leave = 2,
	-- 			filetype = { "text", "markdown" },
	-- 		}) -- Leave bold pair
	-- 		add_rule({
	-- 			char = "<BS>",
	-- 			at = esc_char .. [[\%#]] .. esc_char,
	-- 			delete = char,
	-- 			filetype = { "text", "markdown" },
	-- 		}) -- Delete pair
	-- 	end
	--
	-- 	vim.g["lexima#default_rules"] = {
	-- 		{ char = "(", input_after = ")" },
	-- 		{ char = "(", at = [[\\\%#]] },
	-- 		{ char = ")", at = [[\%#)]], leave = 1 },
	-- 		{ char = "<BS>", at = [[(\%#)]], delete = 1 },
	-- 		{ char = "{", input_after = "}" },
	-- 		{ char = "}", at = [[\%#}]], leave = 1 },
	-- 		{ char = "<BS>", at = [[{\%#}]], delete = 1 },
	-- 		{ char = "[", input_after = "]" },
	-- 		{ char = "[", at = [[\\\%#]] },
	-- 		{ char = "]", at = [==[\%#]]==], leave = 1 },
	-- 		{ char = "<BS>", at = [==[\[\%#\]]==], delete = 1 },
	-- 		{ char = '"', input_after = '"' },
	-- 		{ char = '"', at = [[\%#"]], leave = 1 },
	-- 		{ char = '"', at = [[\\\%#]] },
	-- 		{ char = '"', at = [[^\s*\%#]], filetype = "vim" },
	-- 		{ char = '"', at = [[\%#\s*$]], filetype = "vim" },
	-- 		{ char = "<BS>", at = [["\%#"]], delete = 1 },
	-- 		{ char = '"', at = [[""\%#]], input_after = '"""' },
	-- 		{ char = '"', at = [[\%#"""]], leave = 3 },
	-- 		{ char = "<BS>", at = [["""\%#"""]], input = "<BS><BS><BS>", delete = 3 },
	-- 		{ char = "'", input_after = "'" },
	-- 		{ char = "'", at = [[\%#'']], leave = 1 },
	-- 		{ char = "'", at = [[\w\%#''\@!]] },
	-- 		{ char = "'", at = [[\\\%#]] },
	-- 		{ char = "'", at = [[\\\%#]], leave = 1, filetype = { "vim", "sh", "csh", "ruby", "tcsh", "zsh" } },
	-- 		{ char = "'", filetype = { "haskell", "lisp", "clojure", "ocaml", "reason", "scala", "rust" } },
	-- 		{ char = "<BS>", at = "'\\%#'", delete = 1 },
	-- 		{ char = "'", at = "''\\%#", input_after = "'''" },
	-- 		{ char = "'", at = "\\%#'''", leave = 3 },
	-- 		{ char = "<BS>", at = "'''\\%#'''", input = "<BS><BS><BS>", delete = 3 },
	-- 		{ char = "`", input_after = "`" },
	-- 		{ char = "`", at = [[\%#`]], leave = 1 },
	-- 		{ char = "<BS>", at = [[`\%#`]], delete = 1 },
	-- 		{ char = "`", filetype = { "ocaml", "reason" } },
	-- 		{ char = "`", at = [[``\%#]], input_after = "```" },
	-- 		{ char = "`", at = [[\%#```]], leave = 3 },
	-- 		{ char = "<BS>", at = [[```\%#```]], input = "<BS><BS><BS>", delete = 3 },
	-- 	}
	--
	-- 	vim.g["lexima#newline_rules"] = {
	-- 		{ char = "<CR>", at = [[(\%#)]], input_after = "<CR>" },
	-- 		{
	-- 			char = "<CR>",
	-- 			at = [[(\%#$]],
	-- 			input_after = "<CR>)",
	-- 			except = [[\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1\)]],
	-- 		},
	-- 		{ char = "<CR>", at = [[{\%#}]], input_after = "<CR>" },
	-- 		{
	-- 			char = "<CR>",
	-- 			at = [[{\%#$]],
	-- 			input_after = "<CR>}",
	-- 			except = [[\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1\}]],
	-- 		},
	-- 		{ char = "<CR>", at = [==[\[\%#]]==], input_after = "<CR>" },
	-- 		{
	-- 			char = "<CR>",
	-- 			at = [==[\[\%#$]==],
	-- 			input_after = "<CR>]",
	-- 			except = [==[\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1\]]==],
	-- 		},
	-- 		{ char = "<CR>", at = [[^```\(\S*\)\%#```]], input = "<CR>", input_after = "<CR>" },
	-- 	}
	--
	-- 	vim.g["lexima#space_rules"] = {
	-- 		{ char = "<Space>", at = [[(\%#)]], input_after = "<Space>" },
	-- 		{ char = ")", at = [[\%# )]], leave = 2 },
	-- 		{ char = "<BS>", at = [[( \%# )]], delete = 1 },
	-- 		{ char = "<Space>", at = [[{\%#}]], input_after = "<Space>" },
	-- 		{ char = "}", at = [[\%# }]], leave = 2 },
	-- 		{ char = "<BS>", at = [[{ \%# }]], delete = 1 },
	-- 		{ char = "<Space>", at = [==[\[\%#]]==], input_after = "<Space>" },
	-- 		{ char = "]", at = [==[\%# ]]==], leave = 2 },
	-- 		{ char = "<BS>", at = [==[\[ \%# ]]==], delete = 1 },
	-- 	}
	--
	-- 	for _, rule in ipairs(vim.g["lexima#default_rules"]) do
	-- 		add_rule(rule)
	-- 	end
	-- 	for _, rule in ipairs(vim.g["lexima#newline_rules"]) do
	-- 		add_rule(rule)
	-- 	end
	-- 	for _, rule in ipairs(vim.g["lexima#space_rules"]) do
	-- 		add_rule(rule)
	-- 	end
	--
	-- 	local function lexima_endwise_rules()
	-- 		for _, at in pairs({
	-- 			"fu",
	-- 			"fun",
	-- 			"func",
	-- 			"funct",
	-- 			"functi",
	-- 			"functio",
	-- 			"function",
	-- 			"if",
	-- 			"wh",
	-- 			"whi",
	-- 			"whil",
	-- 			"while",
	-- 			"for",
	-- 			"try",
	-- 			"def",
	-- 		}) do
	-- 			make_endwise_rule([[^\s*]] .. at .. [[\>.*\%#$]], "end" .. at, "vim", {})
	-- 		end
	--
	-- 		for _, at in pairs({ "aug", "augroup" }) do
	-- 			make_endwise_rule([[^\s*]] .. at .. [[\s\+.\+\%#$]], at .. " END", "vim", {})
	-- 		end
	--
	-- 		-- ruby
	-- 		make_endwise_rule(
	-- 			[[^\s*\%(module\|def\|class\|if\|unless\|for\|while\|until\|case\)\>\%(.*[^.:@$]\<end\>\)\@!.*\%#$]],
	-- 			"end",
	-- 			"ruby",
	-- 			{}
	-- 		)
	-- 		make_endwise_rule([[^\s*\%(begin\)\s*\%#$]], "end", "ruby", {})
	-- 		make_endwise_rule([[\%(^\s*#.*\)\@<!do\%(\s*|.*|\)\?\s*\%#$]], "end", "ruby", {})
	-- 		make_endwise_rule([[\<\%(if\|unless\)\>.*\%#$]], "end", "ruby", "rubyConditionalExpression")
	--
	-- 		-- elixir
	-- 		make_endwise_rule([[\%(^\s*#.*\)\@<!do\s*\%#$]], "end", "elixir", {})
	--
	-- 		-- sh
	-- 		make_endwise_rule([[^\s*if\>.*\%#$]], "fi", { "sh", "zsh" }, {})
	-- 		make_endwise_rule([[^\s*case\>.*\%#$]], "esac", { "sh", "zsh" }, {})
	-- 		make_endwise_rule([[\%(^\s*#.*\)\@<!do\>.*\%#$]], "done", { "sh", "zsh" }, {})
	--
	-- 		-- julia
	-- 		make_endwise_rule(
	-- 			[[\%(^\s*#.*\)\@<!\<\%(module\|struct\|function\|if\|for\|while\|do\|let\|macro\)\>\%(.*\<end\>\)\@!.*\%#$]],
	-- 			"end",
	-- 			"julia",
	-- 			{}
	-- 		)
	-- 		make_endwise_rule([[\%(^\s*#.*\)\@<!\s*\<\%(begin\|try\|quote\)\s*\%#$]], "end", "julia", {})
	-- 	end
	--
	-- 	local function lua_endwise_rules()
	-- 		-- Lua endwise rules:
	-- 		-- if vim.g.lexima_enable_endwise_rules == 1 then
	-- 		make_endwise_rule([[^\s*if\>.*then\%(.*[^.:@$]\<end\>\)\@!.*\%#]], "end", "lua", {})
	-- 		make_endwise_rule([[^\s*\%(for\|while\)\>.*do\%(.*[^.:@$]\<end\>\)\@!.*\%#]], "end", "lua", {})
	-- 		make_endwise_rule([[^\s*\%(local\)\=.*function\>\%(.*[^.:@$]\<end\>\)\@!.*\%#]], "end", "lua", {})
	-- 		-- end
	-- 		return nil
	-- 	end
	--
	-- 	-- Lexima Rules
	-- 	-- Correct unbalanced pairs:
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[""\%#"]],
	-- 		delete = 1,
	-- 		input = [[<BS><BS>"]],
	-- 		input_after = [["]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[((\%#)]],
	-- 		delete = 1,
	-- 		input = [[<BS><BS>(]],
	-- 		input_after = [[)]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[[^(](\%#))]],
	-- 		delete = 1,
	-- 	})
	--
	-- 	-- Markdown rules:
	-- 	-- Links:
	-- 	add_rule({
	-- 		char = "]",
	-- 		at = [=[\[[^]]*\%#\]]=],
	-- 		except = [=[\[@[^]]*\%#\]]=],
	-- 		leave = "]",
	-- 		input = "(",
	-- 		input_after = ")",
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	-- Blockquotes:
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		input = "<BS><BS>",
	-- 		at = [[^> \%#]],
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^> .\+\%#$]],
	-- 		input = "<CR>> ",
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^> \%#$]],
	-- 		input = "<BS><BS><CR>",
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	add_rule({
	-- 		char = ">",
	-- 		input = "> ",
	-- 		at = [[^\%#]],
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	-- Unordered Lists:
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^\s*\([*-]\) .*\%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		with_submatch = true,
	-- 		input = [[<CR>\1 ]],
	-- 		except = [[^\s*\([*-]\) \%#$]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^\s*\([*-]\) \%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		input = [[<Home><C-O>"_D<CR>]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[^\(\s*\)[*-] \%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		with_submatch = true,
	-- 		input = [[<Home><C-O>"_D\1]],
	-- 	})
	-- 	-- Ordered Lists (including automatic increment):
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^\s*\([0-9]\+\)\..*\%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		with_submatch = true,
	-- 		input = [[<CR>\1. <Home><C-o>:exec "normal! \<c-a\>" "$"<CR>]],
	-- 		except = [[^\s*\([0-9]\)\. \%#$]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<CR>",
	-- 		at = [[^\s*\([0-9]\+\)\. \%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		input = [[<Home><C-O>"_D<CR>]],
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[^\(\s*\)[0-9]\+\. \%#$]],
	-- 		filetype = { "text", "markdown" },
	-- 		with_submatch = true,
	-- 		input = [[<Home><C-O>"_D\1]],
	-- 	})
	-- 	-- Tasks:
	-- 	add_rule({
	-- 		char = "[",
	-- 		input = "[ ]",
	-- 		at = [[^\s*[*-0-9]\+\.\{0,1\} \s*\%#]],
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		input = "<BS><BS><BS>",
	-- 		at = [[^\s*[*-\d]\+\.\{0,1\} \s*\[.\]\%#]],
	-- 		filetype = { "text", "markdown" },
	-- 	})
	-- 	-- Bold/Italic Pairs:
	-- 	make_markdown_bi_rule("*", true)
	-- 	make_markdown_bi_rule("_")
	--
	-- 	-- Lexima endwise rules:
	-- 	lexima_endwise_rules()
	-- 	-- Lua endwise rules:
	-- 	lua_endwise_rules()
	--
	-- 	-- Rules for help files:
	-- 	add_rule({
	-- 		char = "|",
	-- 		input_after = "|",
	-- 		filetype = "help",
	-- 	})
	-- 	add_rule({
	-- 		char = "|",
	-- 		at = [[\%#|]],
	-- 		leave = 1,
	-- 		filetype = "help",
	-- 	})
	-- 	add_rule({
	-- 		char = "<BS>",
	-- 		at = [[|\%#|]],
	-- 		delete = 1,
	-- 		filetype = "help",
	-- 	})
	-- end,
}
